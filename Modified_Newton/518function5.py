import numpy as np
from numpy import linalg as LA
epsilon = 10 ** -8
N = 1000
Max_LS_iter = 20
mu = 10 ** -4
v = 0.9
y = 10 ** -4


def function(num1, num2, c):
    return ((num1 - 1) ** 2) + ((num2 -1) ** 2) + (c *((num1 ** 2) + (num2 ** 2) - 0.25))
def gradient(num1, num2, c):
    a = ((4 * (num1 ** 3) * c) + (4*c * num1 * (num2 ** 2)) + (2 * num1) - (num1 * c)) - 2
    b = ((4 * (num2 ** 3) * c) + (4*c * (num1 ** 2) * num2) + (2 * num2) - (num2 * c)) - 2
    return np.array([a,b])

def hessian(num1, num2, c):
    a = (12 * (num1 ** 2) * c) + (4 * c * (num2 ** 2)) + 2 - c
    b = 8 * c * num1 * num2
    c = 8 * c * num1 * num2
    d = (12 * (num2 ** 2) * c) + (4 * c * (num1 ** 2)) + 2 - c
    return np.array([[a,b],[c,d]])




def backtracking(mu, p_k, x_k, Max_LS_iter=20):
    n = 0
    alpha = 1
    arg1 = np.add(x_k, (alpha * p_k))
    arg2 = x_k
    while function(arg1[0], arg1[1],c) > (function(arg2[0], arg2[1], c) + (mu * alpha) * np.matmul(np.transpose(gradient(arg2[0], arg2[1], c)), p_k)) and n <= Max_LS_iter:
        alpha = alpha / 2
        n += 1
        print(n)
    return alpha

def modified_newton(x0, c, epsilon=10 ** -8, N=1000, Max_LS_iter=20, mu=10 ** -4, v=0.9, y=10 ** -4):
    data = [['iteration', 'function at x_k', 'norm of gradient', 'step size', 'x_k']]
    k = 0
    x_k = x0
    h = hessian(x_k[0],x_k[1],c)
    print("h = ",h)
    print((LA.norm(gradient(x_k[0],x_k[1], c), 2)))
    print((1 + abs(function(x_k[0],x_k[1], c))))
    while (LA.norm(gradient(x_k[0],x_k[1], c),2) / (1 + abs(function(x_k[0],x_k[1], c)))) > epsilon and k <= N:
        #Check that hessian is positive definite
        eig_values, eig_vectors = LA.eig(h)
        shape = eig_values.shape
        print("eig values =",eig_values)
        print(np.less_equal(eig_values,0).any())
        if np.less_equal(eig_values,0).any() =='True':
            PD_adjust = abs(np.amin(eig_values)) + 0.01
            print("PD_adjust =", PD_adjust)
            print((PD_adjust * np.identity(2, dtype=float)))
            h = np.add(h, (PD_adjust * np.identity(2, dtype=float))) #acceptable dimensions
            print("h changed = ", h)
        p_k = LA.solve(h,(-1 * gradient(x_k[0],x_k[1],c)))
        print("p_k = ", p_k)
        alpha = backtracking(mu, p_k, x_k)
        x_k = x_k + alpha * p_k
        k += 1
        h = hessian(x_k[0] , x_k[1],c)
        data.append([k, function(x_k[0],x_k[1],c), LA.norm(gradient(x_k[0], x_k[1],c)), alpha, x_k])
    return data

x0 = np.array([1,-1])
c = int(input("Enter C Value: "))
data = modified_newton(x0,c)
if len(data) > 15:
    a = data[0:11]
    a.extend(data[len(data) - 6:len(data) - 1])
    for item in a:
        print(item)
else:
    for item in data:
        print(item)

# c = 1
# ['iteration', 'function at x_k', 'norm of gradient', 'step size', 'x_k']
# [1, 5.644553898574063, 9.368972939169561, 1, array([ 0.55845411, -1.06328502])]
# [2, 5.644554243949152, 9.368973135929952, 4.76837158203125e-07, array([ 0.55845398, -1.06328508])]
# [3, 5.644554589324397, 9.368973332690972, 4.76837158203125e-07, array([ 0.55845386, -1.06328514])]
# [4, 5.644554934699796, 9.368973529452626, 4.76837158203125e-07, array([ 0.55845374, -1.0632852 ])]
# [5, 5.644555280075352, 9.368973726214906, 4.76837158203125e-07, array([ 0.55845362, -1.06328526])]
# [6, 5.644555625451064, 9.368973922977816, 4.76837158203125e-07, array([ 0.55845349, -1.06328532])]
# [7, 5.64455597082693, 9.368974119741354, 4.76837158203125e-07, array([ 0.55845337, -1.06328538])]
# [8, 5.6445563162029515, 9.368974316505518, 4.76837158203125e-07, array([ 0.55845325, -1.06328544])]
# [9, 5.644556661579127, 9.368974513270313, 4.76837158203125e-07, array([ 0.55845313, -1.0632855 ])]
# [10, 5.644557006955461, 9.368974710035737, 4.76837158203125e-07, array([ 0.55845301, -1.06328556])]
# [996, 5.644897623596027, 9.369169026672989, 4.76837158203125e-07, array([ 0.55833242, -1.06334454])]
# [997, 5.644897969125655, 9.369169224058936, 4.76837158203125e-07, array([ 0.5583323, -1.0633446])]
# [998, 5.644898314655439, 9.369169421445513, 4.76837158203125e-07, array([ 0.55833218, -1.06334466])]
# [999, 5.644898660185378, 9.369169618832721, 4.76837158203125e-07, array([ 0.55833206, -1.06334472])]
# [1000, 5.644899005715473, 9.369169816220559, 4.76837158203125e-07, array([ 0.55833193, -1.06334478])]

# c = 10

# ['iteration', 'function at x_k', 'norm of gradient', 'step size', 'x_k']
# [1, 15.198511098834459, 53.40613498068387, 1, array([ 0.52370342, -1.0299635 ])]
# [2, 14.715249632471746, 46.45682926057809, 1, array([ 0.16181041, -1.09006781])]
# [3, 14.7152523925946, 46.45684286415274, 4.76837158203125e-07, array([ 0.16181032, -1.09006792])]
# [4, 14.715255152719681, 46.45685646774089, 4.76837158203125e-07, array([ 0.16181024, -1.09006803])]
# [5, 14.71525791284699, 46.45687007134251, 4.76837158203125e-07, array([ 0.16181015, -1.09006814])]
# [6, 14.71526067297653, 46.45688367495763, 4.76837158203125e-07, array([ 0.16181006, -1.09006826])]
# [7, 14.7152634331083, 46.45689727858625, 4.76837158203125e-07, array([ 0.16180997, -1.09006837])]
# [8, 14.715266193242295, 46.45691088222832, 4.76837158203125e-07, array([ 0.16180988, -1.09006848])]
# [9, 14.715268953378526, 46.45692448588395, 4.76837158203125e-07, array([ 0.1618098 , -1.09006859])]
# [10, 14.715271713516989, 46.456938089553056, 4.76837158203125e-07, array([ 0.16180971, -1.0900687 ])]
# [996, 14.717994295101356, 46.470357873706135, 4.76837158203125e-07, array([ 0.16172306, -1.09017869])]
# [997, 14.717997057441007, 46.47037149069647, 4.76837158203125e-07, array([ 0.16172297, -1.0901788 ])]
# [998, 14.717999819782893, 46.47038510770031, 4.76837158203125e-07, array([ 0.16172288, -1.09017891])]
# [999, 14.718002582127006, 46.47039872471766, 4.76837158203125e-07, array([ 0.16172279, -1.09017902])]
# [1000, 14.718005344473355, 46.47041234174849, 4.76837158203125e-07, array([ 0.16172271, -1.09017913])]


# c = 100
# ['iteration', 'function at x_k', 'norm of gradient', 'step size', 'x_k']
# [1, 111.7548072194262, 497.6187838276344, 1, array([ 0.51975768, -1.02665495])]
# [2, 98.48406595726878, 410.5832528471781, 1, array([ 0.14204511, -1.07892706])]
# [3, 98.48408841510754, 410.5833856940281, 4.76837158203125e-07, array([ 0.14204501, -1.07892718])]
# [4, 98.48411087297171, 410.5835185410444, 4.76837158203125e-07, array([ 0.14204491, -1.07892729])]
# [5, 98.4841333308614, 410.5836513882275, 4.76837158203125e-07, array([ 0.14204482, -1.0789274 ])]
# [6, 98.48415578877652, 410.5837842355768, 4.76837158203125e-07, array([ 0.14204472, -1.07892752])]
# [7, 98.48417824671711, 410.58391708309296, 4.76837158203125e-07, array([ 0.14204462, -1.07892763])]
# [8, 98.48420070468316, 410.58404993077545, 4.76837158203125e-07, array([ 0.14204452, -1.07892775])]
# [9, 98.4842231626747, 410.58418277862455, 4.76837158203125e-07, array([ 0.14204442, -1.07892786])]
# [10, 98.48424562069164, 410.58431562664015, 4.76837158203125e-07, array([ 0.14204432, -1.07892797])]
# [996, 98.50640161720455, 410.71538482904657, 4.76837158203125e-07, array([ 0.14194753, -1.07904044])]
# [997, 98.5064241003609, 410.71551784151313, 4.76837158203125e-07, array([ 0.14194744, -1.07904056])]
# [998, 98.50644658354271, 410.71565085414625, 4.76837158203125e-07, array([ 0.14194734, -1.07904067])]
# [999, 98.50646906675, 410.71578386694614, 4.76837158203125e-07, array([ 0.14194724, -1.07904079])]
# [1000, 98.50649154998277, 410.71591687991264, 4.76837158203125e-07, array([ 0.14194714, -1.0790409 ])]